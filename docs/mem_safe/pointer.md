# 指针

讲内存安全，如果不讲指针，那一定是缺失的

之前我们其实已经见到过指针了(引用就是一种`安全的指针`) 内存安全这一章节 我们一开始也讲过了 栈和堆的概念 

虽然大多数情况，指针几乎都用来指向堆上的内存，但是指针含义本身不区分堆和栈 

```
struct Apple(i32);

fn main() {

	let a:i32 = 10; // 10这个值 默认是在栈上的 
	let a_ref = &a; // a_ref 引用 指向的内存是栈上的内存 
	
	let apple: Apple = Apple(100); // RUST 对于基础类型，默认内存分配都是在栈上分配的 所以APPLE 的内存也是在栈上的 
	let a_ref = &apple; // a_ref 引用 指向的内存是栈上的内存 
}

```


正常来说，堆上的内存 必须要使用 `堆内存分配器`  才能够申请内存 比如libc的 malloc，或者是Linux内核中的 kmalloc，Vec类型实际上
封装了内存申请的动作，我们将在后面看到更多相关内容 




### 引用
在借用章节，我们已经介绍过了引用，引用是RUST中，为了实现借用语义，封装的 指针类型，让我们在回顾一下: 

 - 引用永远不会为空值
 - 引用指向的内存总是有效的 
 - 引用访问内存，不会出现多人修改的问题

引用指向的内存，可以是栈上的内存，我们目前使用到的引用都是指向栈上的，但是也可以指向堆上的内存(需要借助 Deref特征)

### 原始指针

RUST中一般不会直接使用原始指针 





